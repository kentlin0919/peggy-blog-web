drop extension if exists "pg_net";


  create table "public"."identity" (
    "identity_id" bigint generated by default as identity not null,
    "name" character varying not null
      );


alter table "public"."identity" enable row level security;


  create table "public"."teacher_info" (
    "id" uuid not null,
    "bio" text,
    "specialties" text[],
    "experience_years" integer,
    "base_price" integer,
    "is_public" boolean default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "teacher_code" character(4) not null
      );


alter table "public"."teacher_info" enable row level security;


  create table "public"."user_info" (
    "id" uuid not null,
    "name" text not null,
    "email" text not null,
    "identity_id" bigint,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."user_info" enable row level security;

CREATE UNIQUE INDEX identity_pkey ON public.identity USING btree (identity_id);

CREATE UNIQUE INDEX teacher_info_pkey ON public.teacher_info USING btree (id);

CREATE UNIQUE INDEX teacher_info_teacher_code_unique ON public.teacher_info USING btree (teacher_code);

CREATE UNIQUE INDEX user_info_email_unique ON public.user_info USING btree (email);

CREATE UNIQUE INDEX user_info_identity_unique ON public.user_info USING btree (identity_id);

CREATE UNIQUE INDEX user_info_pkey ON public.user_info USING btree (id);

alter table "public"."identity" add constraint "identity_pkey" PRIMARY KEY using index "identity_pkey";

alter table "public"."teacher_info" add constraint "teacher_info_pkey" PRIMARY KEY using index "teacher_info_pkey";

alter table "public"."user_info" add constraint "user_info_pkey" PRIMARY KEY using index "user_info_pkey";

alter table "public"."teacher_info" add constraint "teacher_info_id_fkey" FOREIGN KEY (id) REFERENCES public.user_info(id) ON DELETE CASCADE not valid;

alter table "public"."teacher_info" validate constraint "teacher_info_id_fkey";

alter table "public"."teacher_info" add constraint "teacher_info_teacher_code_unique" UNIQUE using index "teacher_info_teacher_code_unique";

alter table "public"."user_info" add constraint "user_info_email_unique" UNIQUE using index "user_info_email_unique";

alter table "public"."user_info" add constraint "user_info_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_info" validate constraint "user_info_id_fkey";

alter table "public"."user_info" add constraint "user_info_identity_unique" UNIQUE using index "user_info_identity_unique";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.assign_unique_teacher_code()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
declare
  new_code char(4);
begin
  if new.teacher_code is null then
    loop
      new_code := public.generate_teacher_code();
      exit when not exists (
        select 1 from public.teacher_info
        where teacher_code = new_code
      );
    end loop;

    new.teacher_code := new_code;
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_teacher_info_if_teacher()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  -- identity_id = 2 代表老師
  if new.identity_id = 2 then
    insert into public.teacher_info (id)
    values (new.id)
    on conflict (id) do nothing;
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_teacher_code()
 RETURNS character
 LANGUAGE plpgsql
AS $function$
declare
  chars text := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  result text := '';
  i int;
begin
  for i in 1..4 loop
    result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);
  end loop;

  return result::char(4);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_identity_id()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  result_id INTEGER;
BEGIN
  SELECT identity_id INTO result_id
  FROM user_info
  WHERE id = auth.uid();
  
  RETURN result_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.user_info (
    id,
    email,
    name,
    identity_id,
    created_at,
    updated_at
  )
  VALUES (
  new.id,
  new.email,
  COALESCE(new.raw_user_meta_data->>'name', ''),
  1,
  now(),
  now()
);


  RETURN new;
END;
$$;


CREATE OR REPLACE FUNCTION public.has_role(target_role_name text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO public
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.user_info u
    JOIN public.identity i
      ON u.identity_id = i.identity_id
    WHERE u.id = auth.uid()
      AND i.name = target_role_name
  );
END;
$$;


grant delete on table "public"."identity" to "anon";

grant insert on table "public"."identity" to "anon";

grant references on table "public"."identity" to "anon";

grant select on table "public"."identity" to "anon";

grant trigger on table "public"."identity" to "anon";

grant truncate on table "public"."identity" to "anon";

grant update on table "public"."identity" to "anon";

grant delete on table "public"."identity" to "authenticated";

grant insert on table "public"."identity" to "authenticated";

grant references on table "public"."identity" to "authenticated";

grant select on table "public"."identity" to "authenticated";

grant trigger on table "public"."identity" to "authenticated";

grant truncate on table "public"."identity" to "authenticated";

grant update on table "public"."identity" to "authenticated";

grant delete on table "public"."identity" to "service_role";

grant insert on table "public"."identity" to "service_role";

grant references on table "public"."identity" to "service_role";

grant select on table "public"."identity" to "service_role";

grant trigger on table "public"."identity" to "service_role";

grant truncate on table "public"."identity" to "service_role";

grant update on table "public"."identity" to "service_role";

grant delete on table "public"."teacher_info" to "anon";

grant insert on table "public"."teacher_info" to "anon";

grant references on table "public"."teacher_info" to "anon";

grant select on table "public"."teacher_info" to "anon";

grant trigger on table "public"."teacher_info" to "anon";

grant truncate on table "public"."teacher_info" to "anon";

grant update on table "public"."teacher_info" to "anon";

grant delete on table "public"."teacher_info" to "authenticated";

grant insert on table "public"."teacher_info" to "authenticated";

grant references on table "public"."teacher_info" to "authenticated";

grant select on table "public"."teacher_info" to "authenticated";

grant trigger on table "public"."teacher_info" to "authenticated";

grant truncate on table "public"."teacher_info" to "authenticated";

grant update on table "public"."teacher_info" to "authenticated";

grant delete on table "public"."teacher_info" to "service_role";

grant insert on table "public"."teacher_info" to "service_role";

grant references on table "public"."teacher_info" to "service_role";

grant select on table "public"."teacher_info" to "service_role";

grant trigger on table "public"."teacher_info" to "service_role";

grant truncate on table "public"."teacher_info" to "service_role";

grant update on table "public"."teacher_info" to "service_role";

grant delete on table "public"."user_info" to "anon";

grant insert on table "public"."user_info" to "anon";

grant references on table "public"."user_info" to "anon";

grant select on table "public"."user_info" to "anon";

grant trigger on table "public"."user_info" to "anon";

grant truncate on table "public"."user_info" to "anon";

grant update on table "public"."user_info" to "anon";

grant delete on table "public"."user_info" to "authenticated";

grant insert on table "public"."user_info" to "authenticated";

grant references on table "public"."user_info" to "authenticated";

grant select on table "public"."user_info" to "authenticated";

grant trigger on table "public"."user_info" to "authenticated";

grant truncate on table "public"."user_info" to "authenticated";

grant update on table "public"."user_info" to "authenticated";

grant delete on table "public"."user_info" to "service_role";

grant insert on table "public"."user_info" to "service_role";

grant references on table "public"."user_info" to "service_role";

grant select on table "public"."user_info" to "service_role";

grant trigger on table "public"."user_info" to "service_role";

grant truncate on table "public"."user_info" to "service_role";

grant update on table "public"."user_info" to "service_role";


  create policy "Users can read own profile"
  on "public"."user_info"
  as permissive
  for select
  to public
using ((auth.uid() = id));



  create policy "admin_or_self_can_select"
  on "public"."user_info"
  as permissive
  for select
  to public
using (((id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM (public.user_info me
     JOIN public.identity i ON ((i.identity_id = me.identity_id)))
  WHERE ((me.id = auth.uid()) AND (i.identity_id < 3))))));


CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


